module Test.Main where

import Prelude

import Data.Function (apply, applyFlipped)
import Data.Time.Duration as Duration
import Data.Tuple (Tuple(..))
import Data.Map (Map)
import Data.Map as Map
import Data.Maybe (Maybe(..), fromMaybe)

import Control.Monad.Aff (Aff, delay, forkAff, makeAff)
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Class (liftEff)
import Control.Monad.Eff.Ref (REF)
import Control.Monad.Eff.Console as C

import Test.Spec (pending, describe, it)
import Test.Spec.Assertions (shouldEqual)
import Test.Spec.Reporter.Console (consoleReporter)
import Test.Spec.Runner (RunnerEffects, run)

import Signal as S
import Signal.Channel as SC
import Signal.Time (debounce)

import Test.Signal (expect')

import Rpd as R

infixr 0 apply as <|
infixl 1 applyFlipped as |>

data MyNodeType = SumNode | CustomNode
data MyChannelType = NumberChannel | StringChannel

main_ :: forall eff. Eff (RunnerEffects ( ref :: REF, channel :: SC.CHANNEL | eff )) Unit
main_ = run [consoleReporter] do
  describe "Rpd" do
    describe "Running the application" do
      it "runs with provided network structure" $ makeAff \err succ -> do
        let
          toInt = (\_ -> 20)
          app' = R.run [] do
            let
              myPatch = R.patch "MyPatch"
              sumNode = R.node SumNode "sum"
              inletA = R.getInlet "a" sumNode
              inletB = R.getInlet "b" sumNode
              myCustomNode =
                R.node CustomNode "Custom"
                  |> R.addInlet (R.inlet NumberChannel "a" |> R.allow
                      [ Tuple StringChannel toInt ])
                  |> R.addInlet (R.inlet NumberChannel "b" |> R.default 10)
                  |> R.addOutlet (R.outlet NumberChannel "out")
                  -- |> R.process (\inlets -> { out: inlets.a * inlets.b })
                  |> R.process
                    (\inlets ->
                      Map.empty
                      -- Map.singleton "out"
                      --   ((Map.lookup "a" inlets |> fromMaybe (R.Data 0)) *
                      --    (Map.lookup "b" inlets |> fromMaybe (R.Data 0)))
                    )

            inletA |> R.send 10 |> R.send 20
            inletB |> R.send 10 |> R.send 10 |> R.send 5
            -- inletB |> R.send "10" |> R.send "10" |> R.send "5"
            myCustomNode |> R.getInlet "a" |> R.send 12 |> R.send 11
            myCustomNode |> R.getOutlet "out" |> R.connect (sumNode |> R.getInlet "a")
            myPatch |> R.addNode sumNode
            myCustomNode |> R.getInlet "b" |> R.send 13
            myNetwork <- R.network |> R.addPatch myPatch
            pure R.network
            R.network
        app <- R.run [] R.network
        messages <- R.getMessages app
        -- _ <- forkAff $ expect' ?what []
        liftEff (S.runSignal ?what)
        -- liftEff (S.runSignal (messages S.~> show S.~> C.log))
        -- S.runSignal (map show messages S.~> C.log)

  -- describe "purescript-spec" do
  --   describe "Attributes" do
  --     it "awesome" do
  --       let isAwesome = true
  --       isAwesome `shouldEqual` true
  --     pending "feature complete"
  --   describe "Features" do
  --     it "runs in NodeJS" $ pure unit
  --     it "runs in the browser" $ pure unit
  --     it "supports streaming reporters" $ pure unit
  --     it "supports async specs" do
  --       delay (Duration.Milliseconds 100.0)
  --       res <- pure "Alligator"
  --       res `shouldEqual` "Alligator"
  --     it "is PureScript 0.10.x compatible" $ pure unit
  --     it "tests signals"
  --       $ expect' (S.constant "lol") ["lol"]
  --     it "tests async signals" $ do
  --       chan <- liftEff $ SC.channel 0
  --       let sig = debounce 10.0 $ SC.subscribe chan
  --           send' = liftEff <<< SC.send chan
  --       _ <- forkAff $ expect' sig [0,2,4]
  --       wait 20.0
  --       send' 1
  --       wait 5.0
  --       send' 2
  --       wait 20.0
  --       send' 3
  --       wait 5.0
  --       send' 4
  --       wait 20.0



wait :: forall e. Number -> Aff e Unit
wait t = do
  delay (Duration.Milliseconds t)
  pure unit



> myMap' = Map.empty :: Map R.InletPath String

> myMap2 = Map.insert (R.InletPath (R.NodePath (R.PatchId 7) 11) 2) "foo" myMap'
> Map.lookup (R.InletPath (R.NodePath (R.PatchId 7) 11) 2) myMap2
(Just "foo")

> Map.lookup (R.InletPath (R.NodePath (R.PatchId 7) 11) 1) myMap2
Nothing

> Map.lookup (R.InletPath (R.NodePath (R.PatchId 7) 11) 3) myMap2
Nothing

> myMap3 = Map.insert (R.InletPath (R.NodePath (R.PatchId 7) 9) 2) "bar" myMap2
> Map.lookup (R.InletPath (R.NodePath (R.PatchId 7) 11) 3) myMap3
Nothing

> Map.lookup (R.InletPath (R.NodePath (R.PatchId 7) 11) 2) myMap3
(Just "foo")

> myMap3
(fromFoldable [(Tuple P7/N11/I2 "foo"),(Tuple P7/N9/I2 "bar")])

> Map.lookup (R.InletPath (R.NodePath (R.PatchId 7) 11) 4) myMap3
Nothing

> Map.lookup (R.InletPath (R.NodePath (R.PatchId 7) 10) 4) myMap3 --- WHY??
(Just "foo")

> myMap3
(fromFoldable [(Tuple P7/N11/I2 "foo"),(Tuple P7/N9/I2 "bar")])

> R.InletPath (R.NodePath (R.PatchId 7) 10) 4 == R.InletPath (R.NodePath (R.PatchId 7) 11) 2
false

> R.InletPath (R.NodePath (R.PatchId 7) 11) 2
P7/N11/I2

> compare (R.InletPath (R.NodePath (R.PatchId 7) 10) 4) (R.InletPath (R.NodePath (R.PatchId 7) 11) 2)
EQ -- that's it!





R.InletPath (R.NodePath (R.PatchId 7) 11) 2 == R.InletPath (R.NodePath (R.PatchId 6) 11) 2


myNode :: String -> R.LazyNode MyData
myNode nodeId =
  R.node "f"
    [ R.inletWithDefault "a" (Str' (nodeId <> "a") "i")
    , R.inletWithDefault "b" (Str' (nodeId <> "b") "test")
    , R.inlet "f" -- (ST.every (2.0 * ST.second) S.~> Num' (nodeId <> "f"))
    , R.inlet "d" -- (ST.every ST.second S.~> Num' (nodeId <> "d"))
    , R.inletWithDefault "e" (Num' (nodeId <> "e") 3.0)
    ]
    [ R.outlet "c"
    ]
    -- (\_ -> [ "c" /\ Int' 10 ] )


myNetwork :: R.Network MyData
myNetwork =
  R.network
    [ R.patch "Patch One"
      [ myNode "1"
      , myNode "2"
      ] -- >>> connect (patch.getNode 0) "a" (patch.getNode 1) "b"
    ]




main :: âˆ€ e. Eff (dom :: DOM, channel :: SC.CHANNEL | e) Unit
main = do
  documentType <- document =<< window
  element <- getElementById (ElementId "app") $ htmlDocumentToNonElementParentNode documentType
  for_ element (\element -> do
    let renderer = RenderH.renderer element
    liftEff $ R.run renderer myNetwork
  )

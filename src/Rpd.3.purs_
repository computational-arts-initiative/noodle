module Main where
import Prelude

import Data.Foldable (fold)
import Data.Tuple (Tuple)
import Data.Tuple
import Data.Maybe (Maybe)

import Text.Smolder.HTML as H
import Text.Smolder.Markup ((!), text)
import Text.Smolder.Markup (Markup) as H
import Text.Smolder.HTML.Attributes as A

import Text.Smolder.Renderer.HTML (render)

import Color (black, toHexString)

import Flare.Smolder (runFlareHTML)
import Flare

import Signal as S

data MyData
  = Bang
  | Str' String
  | Int' Int


type ProcessF d = (Array (Tuple String d) -> Array (Tuple String d))

type AdaptF d = (d -> d)

data Network d = Network (Array (Patch d))
data Patch d = Patch String (Array (Node d)) (Array Link)
--data Patch = Patch String (Array (Node Unit Unit)) (Array Link)
data Node d = Node String (Array (Inlet d)) (Array (Outlet d)) (ProcessF d) -- (S.Signal Unit)
--data Node a b = Node String (a -> b)
--data Node a b = Node String (Map String Unit -> Map String Unit)
data Inlet d = Inlet String (S.Signal d)
--data Inlet d = Inlet String (Maybe (AdaptF d))
data Outlet d = Outlet String (S.Signal d)
data Link = Link


a :: Int -> Int
a x =
  let a' = 3 :: Int
  in a' + x


myNode =
  Node "f"
    [ Inlet "a" (S.constant (Str' "i"))
    , Inlet "b" (S.constant (Int' 2))
    ]
    [ Outlet "c" (S.constant (Int' 6))
    ]
    (\_ -> [ (Tuple "c" (Int' 10) ) ] )


myNetwork :: Network MyData
myNetwork =
  Network
    [ Patch "p"
      [ myNode
      , myNode
      ]
      []
    ]


listen :: Network MyData -> S.Signal MyData
listen nw = S.constant Bang


render :: forall e. Network MyData -> H.Markup e
render nw =
  H.p $ text (fold ["A", "B"] <> show (a 5))

renderData :: forall e. MyData -> H.Markup e
renderData d =
  H.p $ text (fold ["A", "B"] <> show (a 5))



main = void do
      nwSignal <- S.constant myNetwork
      --game <- S.foldp step start signal
      S.runSignal (map render $ S.constant myNetwork)
      -- dataSignal <- S.constant Bang
      -- S.runSignal (map renderData dataSignal)

--runFlareHTML "controls" "output" ui

-- This is the full user interface definition:
ui = markup <$> string    "Title"     "Try Flare!"
            <*> color     "Color"     black
            <*> intSlider "Font size" 5 50 26
            <*> boolean   "Italic"    false


markup title color fontSize italic = do
  H.h1 ! A.style ("color: " <> toHexString color <> ";" <>
                  "font-size: " <> show fontSize <> "px;" <>
                  "font-style: " <> if italic then "italic" else "normal")
       $ (text title)

  H.p $ text (fold ["A", "B"] <> show (a 5))


-- foreign import asBody """
--   function asBody(html) {
--     return function() {
--       onload = function() {
--         document.body.innerHTML = html;
--       };
--     };
--   }""" :: forall eff. String -> Eff (dom :: DOM | eff) Unit

-- main = asBody $ render view
